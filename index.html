<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
  <title>Big</title>
  <link href='big.css' rel='stylesheet' type='text/css' />
  <link href='styles/vs2015.css' rel='stylesheet' type='text/css' />
  <style>
    .new-shiny { background: #aaaaaa; }
    :-webkit-full-screen {
      width: 100%;
      height: 100%;
    }
    .light {
      background: #f8f8f8;
      color: #4C5859;
    }

    .light em {
      color: #26CC8F;
    }

    .light a {
      color: #05A8AA;
    }

    .light a:hover {
      color: #058A8C;
    }

    code {
      padding: 20px 100px 30px 50px !important;
    }
  </style>
  <script src='big.js'></script>
  <script src='highlight.js'></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>
  // document.addEventListener('keydown', ({ key }) => {
  //   if (key !== 'f') return
  //
  //   console.log('document.fullscreenEnabled', document.fullscreenEnabled)
  //
  //   if (document.fullscreenElement) {
  //     document.exitFullscreen()
  //   } else {
  //     document.documentElement.requestFullscreen()
  //   }
  // })
  </script>
</head>
<body id='body' class='light'>
  <div><center>Collab&nbsp;Summit Montr√©al 2019</center></div>
  <div><center><em>BOB</em> (Future?&nbsp;Streams)</center></div>
  <div>
    1. <em>Why</em><br>
    2. <em>Goals</em><br>
    3. <em>Api</em><br>
    4. <em>Current Status</em><br>
    6. <em>Discussion</em>
  </div>
  <div>
    <center>1. <em>Why</em></center>
  </div>
  <div>
    <center>1. <em>Why</em> reinvent streams?</center>
  </div>
  <div>
    The Streams <em>user experiance</em> is bad
  </div>
  <div>
    Streams <em>performance</em> is underwhelming
  </div>
  <div>
    "If you think streams are a problem in Node.js.... they are." - <a>@matteocollina</a>
  </div>
  <div>
    2. <em>Goals</em>
  </div>
  <div>
    Some terms:
    <ul>
      <li><em>Consumer</em> / "<em>Sink</em>" - API where data goes to.</li><br>
      <li><em>Producer</em> / "<em>Source</em>" - API where data comes from.</li><br>
      <li><em>"Protocol"</em> - combination of a Consumer & Producer</li>
    </ul>
  </div>
  <!-- <div>
    <ul>
      <li><em>Performance</em> and <em>ease-of-use</em> are key.</li>
      <li>Implementable in a performant and usable way for both <em>JS and C++</em>.</li>
      <li>Browser portability is preferable.</li>
    </ul>
  </div> -->
  <div>
    <em>Protocol</em> Goals
    <ul>
      <li>Pull-based</li>
      <li>Binary-only</li>
      <li>Stateless (in-protocol)</li>
      <li>One-to-one (no events)</li>
      <li>Timing agnostic (sync or async)</li>
      <li>No buffering (in-protocol)</li>
      <li>In-line control flow (errors and "end")</li>
    </ul>
  </div>
  <!-- <div>
    Consumer <em>Goals</em>
    <ul>
      <li>Should own any preallocated memory (the buffer).</li>
      <li>Must never make more than one data request upstream at the same time.</li>
    </ul>
  </div> -->
  <div>
    The&nbsp;Current&nbsp;Proposed&nbsp;API
  </div>
  <div>
    Sink API
    <pre><code class="js">
class Sink {
  constructor (opts) {}

  bindSource (source, bindCb) {
    this.source = source

  }

  next (status, error, buffer, bytes) {
    // do stuff with received data

  }
}
</code></pre>
  </div>
  <div>
    Sink API
    <pre><code class="js">
class Sink {
  constructor (opts) {}

  bindSource (source, bindCb) {
    this.source = source
    this.source.bindSink(this)
  }

  next (status, error, buffer, bytes) {
    // do stuff with received data
    this.source.pull(null, buffer)
  }
}
</code></pre>
  </div>
  <div>
    Source API
    <pre><code class="js">
class Source {
  constructor (opts) {}

  bindSink (sink) {
    this.sink = sink
  }

  pull (error, buffer) {
    // get data


  }
}
</code></pre>
  </div>
  <div>
    Source API
    <pre><code class="js">
class Source {
  constructor (opts) {}

  bindSink (sink) {
    this.sink = sink
  }

  pull (error, buffer) {
    // get data
    this.sink.next(status_type.continue, null,
                   buffer, bytesWritten)
  }
}
</code></pre>
  </div>
  <div>
    <pre><code class="js">
class PassThrough {
  bindSource (source) {
    source.bindSink(this)
    this.source = source
    return this
  }

  bindSink (sink) {
    this.sink = sink
  }

  next (status, error, buffer, bytes) {
    this.sink.next(status, error, buffer, bytes)
  }

  pull (error, buffer) {
    this.source.pull(error, buffer)
  }
}
</code></pre>
  </div>
  <div>
    <em>Composing</em> a Stream
    <pre><code class="js">
const { Stream } = require('bob-streams')

const source = new Source(/* args */)
const sink = new Sink(/* args */)

const stream = new Stream(source, sink)
stream.start(error => {
  // The stream is finished when this is called.
})
    </code></pre>
  </div>
  <div>
    Composition with a transform
    <pre><code class="js">
const { Stream } = require('bob-streams')

const source = new Source(/* args */)
const xform = new Transform(/* args */)
const sink = new Sink(/* args */)

const stream = new Stream(source, xform, sink)
stream.start(error => {
  // The stream is finished when this is called.
})
    </code></pre>
  </div>
  <div>
    github.com/<a href="https://github.com/Fishrock123/bob">Fishrock123/bob</a>
    <br>
    <br>
    <small>/diagrams</small>
  </div>
  <div>
    <img src="diagrams/BOB-diagram.png" />
  </div>
  <div>
    <img src="diagrams/BOB-errors-diagram.png" />
  </div>
  <div>
    <center>Current&nbsp;<em>Status</em></center>
  </div>
  <div>
    Current <em>Modules</em>
    <br>
    <ul>
      <li>bob-status</li>
      <li>fs-source</li>
      <li>fs-sink</li>
      <li>zlib-transform</li>
      <li>crc-transform</li>
      <li>github.com/Fishrock123/socket</li>
    </ul>
  </div>
  <div>
    Current <em>Helpers</em>
    <br>
    <pre><code class="js">
Stream(source, ...sinks)

WritableSource() extends Readable
ReadableSink() extends Writable

BufferSource(buffers)

AssertionSource(assertions)
AssertionSink(assertions)
    </code></pre>
  </div>
  <div>
    Current&nbsp;Status&nbsp;is...&nbsp;<em>stalled</em>
    <br>
    ...&nbsp;and&nbsp;possibly&nbsp;<em>(not?)&nbsp;defunct</em>...
  </div>
  <div>
    Discussion!
    <br>
    <br>
    github.com/<a href="https://github.com/Fishrock123/bob">Fishrock123/bob</a>
  </div>
  <div>
    Problem&nbsp;Solving
    <br>
    Groups of 3-5
  </div>
  <div>
    How to enforce the API (presently only convention)?
  </div>
  <div>
    Use-cases that are better served via <em><code>writev</code></em> aside from theoretical performance?
  </div>
  <div>
    An API for neatly giving buffer allocation hints (i.e. source to sink)?
  </div>
</body>
</html>
